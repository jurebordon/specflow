# Adoption Mode

> For adding SpecFlow to existing projects.

## When to Use

- Existing codebase that needs better AI-assisted workflow
- Partial documentation exists
- Working feature-by-feature, not from a grand PRD
- Team already has established patterns
- Want structure without rewriting everything

## Entry Point

1. Existing codebase
2. Existing documentation (if any)
3. Feature/task-level requirements (not full PRD)

## Setup Flow

```
┌─────────────────────────────────────────┐
│  1. Discovery                           │
│     - What docs exist?                  │
│     - What's the tech stack?            │
│     - What's the git workflow?          │
└─────────────────────────────────────────┘
                    │
                    ▼
┌─────────────────────────────────────────┐
│  2. Optional: Codebase Scan             │
│     - Only if you approve               │
│     - Detect patterns and structure     │
│     - Identify conventions              │
└─────────────────────────────────────────┘
                    │
                    ▼
┌─────────────────────────────────────────┐
│  3. Document Current State              │
│     - Derive OVERVIEW from code         │
│     - Light VISION (or skip)            │
│     - ADR for known decisions           │
└─────────────────────────────────────────┘
                    │
                    ▼
┌─────────────────────────────────────────┐
│  4. Add Operational Layer               │
│     - CLAUDE.md for AI context          │
│     - SESSION_LOG.md for tracking       │
│     - ROADMAP.md for current work       │
│     - Commands for your git workflow    │
└─────────────────────────────────────────┘
                    │
                    ▼
┌─────────────────────────────────────────┐
│  5. Start using incrementally           │
│     - Use session workflow              │
│     - Build docs over time              │
│     - Don't try to document everything  │
└─────────────────────────────────────────┘
```

## Key Differences from Greenfield

| Aspect | Greenfield | Adoption |
|--------|------------|----------|
| PRD | Required upfront | Optional, derive from features |
| Tech Spec | Generated fresh | Derived from existing code |
| VISION | Full document | Light or skipped |
| OVERVIEW | Forward-looking | Documents what exists |
| Codebase scan | N/A | Optional, with permission |
| Documentation depth | Full | Minimal viable |

## Discovery Questions

Setup will ask:

### Existing Documentation
- Do you have a README? (where?)
- Any existing architecture docs?
- Any decision records or ADRs?
- API documentation?

### Codebase Understanding
- May I scan the codebase to understand structure?
  - If yes: I'll look at folder structure, key files, patterns
  - If no: Please describe the structure

### Tech Stack
- What's the primary language/framework?
- Database(s)?
- Key dependencies?
- Test framework?

### Git Workflow
- Direct merge or PR review?
- CI/CD pipeline? (which platform?)
- Branch naming conventions?
- Required reviewers?

### Current Work Style
- Working from tickets/issues?
- Feature-based development?
- What's the current task/priority?

## What Gets Generated

Minimal but functional:

```
project/
├── CLAUDE.md              # AI context for this project
├── docs_specflow/
│   ├── OVERVIEW.md        # Current system (derived)
│   ├── ROADMAP.md         # Current work tracking
│   ├── WORKFLOW.md        # Your actual process
│   ├── SESSION_LOG.md     # Session tracking
│   ├── ADR.md             # Decisions (may be sparse initially)
│   └── feature_docs/
├── .claude/
│   ├── commands/          # Your git workflow
│   │   ├── plan-session.md
│   │   ├── start-session.md
│   │   ├── end-session.md
│   │   └── verify.md
│   └── agents/            # Relevant roles only
│       └── [roles based on stack]
```

**Not generated by default:**
- VISION.md (add later if needed)
- Frozen PRD/Tech Spec (you don't have them)
- Full agent suite (only relevant roles)

## Codebase Scan

If you allow scanning, the AI will:

1. **Look at structure**
   - Folder organization
   - Key entry points
   - Test locations

2. **Identify patterns**
   - Naming conventions
   - Common imports
   - Architecture style

3. **Detect stack**
   - Language from file extensions
   - Framework from dependencies
   - Database from config/connections

4. **NOT do**
   - Read all files in detail (token expensive)
   - Make changes
   - Judge your code

You can always provide this information manually instead.

## Building Documentation Over Time

Adoption mode is **incremental**. Don't try to document everything upfront.

### Session 1-5: Basics
- CLAUDE.md with project overview
- ROADMAP.md with current work
- SESSION_LOG.md entries
- Basic OVERVIEW.md

### Session 5-15: Patterns Emerge
- Add ADR entries as decisions are made
- Expand OVERVIEW.md as you learn the system
- Refine agent guides based on what you actually do

### Session 15+: Mature
- Consider adding VISION.md if helpful
- ADR becomes valuable historical record
- Documentation reflects actual system

## Feature-Based Work

Without a PRD, work is typically feature-based:

```markdown
# ROADMAP.md for Adoption Mode

## Now
- [ ] [TICKET-123] Add export to CSV feature

## Next
1. [TICKET-124] Fix timezone handling in reports
2. [TICKET-125] Add pagination to user list

## Later
- [TICKET-126] Performance optimization for dashboard
- Improve error handling (no ticket yet)

## Done
- [x] [TICKET-122] Fix login redirect bug (2024-01-10)
```

Link to tickets when they exist. Add items without tickets for internal work.

## Tips

- Start minimal - add docs as you need them
- SESSION_LOG is the most valuable operational doc
- CLAUDE.md is essential for AI context
- Don't backfill history - document forward
- Let patterns emerge before codifying them

## Example: DBT Data Project

A complete walkthrough of adopting SpecFlow for an existing DBT-based data warehouse.

### The Scenario

You have a DBT project that's been running for a year:
- ~50 models across staging, intermediate, and marts layers
- Uses GitLab with MR-based workflow
- CI/CD runs dbt build on every MR
- Work comes from Jira tickets
- Some documentation exists but it's scattered

### Step 1: Discovery Conversation

```
AI: What type of project is this?
You: Adoption

AI: May I scan the codebase?
You: Yes, go ahead

AI: I see this is a DBT project with:
    - dbt_project.yml indicating dbt 1.5+
    - Models in models/ with staging/, intermediate/, marts/ structure
    - Tests in tests/ and schema.yml files
    - Macros in macros/
    - GitLab CI config in .gitlab-ci.yml

    Is this correct?

You: Yes, that's right

AI: What's your git workflow?
You: GitLab MR with CI/CD - we can't merge locally,
    CI runs dbt build and only merges if it passes

AI: Do you use a ticketing system?
You: Jira, tickets are like DATA-123

AI: How much documentation do you want to start with?
You: Minimal - we'll build it up over time
```

### Step 2: Generated CLAUDE.md

```markdown
# Data Warehouse (DBT)

> DBT-based data warehouse for analytics.

## Quick Context

- **Type**: Existing DBT project (adoption mode)
- **Stack**: DBT 1.5+, Snowflake, GitLab CI
- **Git Workflow**: CI/CD Gated (GitLab MR)
- **Tickets**: Jira (DATA-XXX)

## Project Structure

```
models/
├── staging/      # Raw source transformations
├── intermediate/ # Business logic building blocks
└── marts/        # Final consumption models
macros/           # Reusable SQL macros
tests/            # Custom data tests
```

## Documentation

| Doc | Purpose |
|-----|---------|
| [ROADMAP.md](docs_specflow/ROADMAP.md) | Current work |
| [SESSION_LOG.md](docs_specflow/SESSION_LOG.md) | Session history |
| [OVERVIEW.md](docs_specflow/OVERVIEW.md) | Model architecture |
| [ADR.md](docs_specflow/ADR.md) | Modeling decisions |

## Key Commands

```bash
# Run models
dbt run --select model_name+

# Test models
dbt test --select model_name+

# Generate docs
dbt docs generate && dbt docs serve
```

## Session Commands

- `/plan-session` - Plan work
- `/start-session` - Begin (creates branch)
- `/end-session` - Create MR (no local merge!)
- `/pivot-session` - Reassess direction

## Working Agreements

1. One model change per MR when possible
2. Always include tests for new models
3. Run `dbt build --select state:modified+` before MR
4. Link Jira ticket in MR description
```

### Step 3: Generated WORKFLOW.md (DBT-specific)

```markdown
# DBT Development Workflow

## Git Workflow: CI/CD Gated (GitLab)

```
main ◄── GitLab CI ◄── MR Approval ◄── feature/DATA-XXX-description
              │              │
              │              └── Human approval required
              └── dbt build must pass
```

**Important**: Never merge locally. CI handles merge after approval.

## Session Lifecycle

### Before Starting

- [ ] Check ROADMAP.md for current priorities
- [ ] Read last 2-3 SESSION_LOG entries
- [ ] Pull latest main: `git checkout main && git pull`

### During Work

1. Create branch: `git checkout -b feat/DATA-XXX-description`
2. Make model changes
3. Test locally:
   ```bash
   dbt build --select state:modified+ --defer --state ./target
   ```
4. Commit frequently with clear messages

### After Work

1. Final local test:
   ```bash
   dbt build --select state:modified+
   ```

2. Update docs:
   - ROADMAP.md (move task to Done)
   - SESSION_LOG.md (add entry)

3. Push and create MR:
   ```bash
   git push -u origin feat/DATA-XXX-description
   glab mr create --title "feat: description" --description "DATA-XXX"
   ```

4. Wait for CI and approval - **do not merge locally**

## Model Development Standards

### Naming Conventions
- Staging: `stg_[source]__[table]`
- Intermediate: `int_[entity]__[transformation]`
- Marts: `[entity]` or `fct_/dim_` prefix

### Required for New Models
- [ ] Model SQL file
- [ ] Entry in schema.yml with description
- [ ] At least one test (unique, not_null, or custom)
- [ ] Upstream dependencies documented

### Testing
```bash
# Test specific model
dbt test --select model_name

# Test modified models
dbt test --select state:modified+
```
```

### Step 4: Generated Commands (GitLab CI/CD)

**start-session.md**:
```markdown
# Start Session

## 1. Verify Environment

```bash
# Ensure you're on latest main
git checkout main && git pull

# Quick sanity check
dbt debug
```

## 2. Create Branch

```bash
git checkout -b feat/DATA-XXX-description
```

Naming: `feat/DATA-XXX-short-description` or `fix/DATA-XXX-description`

## 3. Begin Work

For DBT model changes:
- Create/modify models in appropriate layer
- Add/update schema.yml entries
- Add tests for new models
- Test incrementally: `dbt build --select model_name+`
```

**end-session.md**:
```markdown
# End Session

## 1. Run Tests

```bash
# Test all modified models
dbt build --select state:modified+
```

All tests must pass before proceeding.

## 2. Update Documentation

**docs_specflow/ROADMAP.md**: Move task to Done
**docs_specflow/SESSION_LOG.md**: Add session entry

## 3. Commit

```bash
git status
git add .
git commit -m "feat(models): description

DATA-XXX"
```

## 4. Create Merge Request

```bash
git push -u origin feat/DATA-XXX-description

glab mr create \
  --title "feat(models): description" \
  --description "## Summary
- [Changes made]

## Testing
- dbt build passes locally
- [Specific tests run]

## Ticket
DATA-XXX" \
  --remove-source-branch
```

**Do NOT merge locally** - CI pipeline will:
1. Run `dbt build` on modified models
2. Require approval
3. Merge automatically on approval

Check status: `glab mr view`
```

### Step 5: Example Session Flow

**Session 1: Add new customer dimension**

```markdown
## Session: 2024-01-15

**Role**: data modeling
**Task**: [DATA-456] Add customer dimension to marts
**Branch**: feat/DATA-456-customer-dim

### Summary
- Created dim_customer in marts/core/
- Added schema.yml with descriptions and tests
- Linked to existing fct_orders

### Files Changed
- models/marts/core/dim_customer.sql (new)
- models/marts/core/schema.yml (updated)

### Decisions
- Used SCD Type 1 (overwrite) for simplicity
- Will add Type 2 tracking later if needed

### Blockers
- None

### Next
- Add customer segmentation fields (DATA-457)

---
```

### Building Documentation Over Time

**Week 1-2**: Basics
- CLAUDE.md captures project context
- SESSION_LOG tracks each change
- ROADMAP reflects Jira priorities

**Week 3-4**: Patterns emerge
- ADR entries for modeling decisions:
  - "ADR-001: Use incremental models for fact tables"
  - "ADR-002: Standardize on UTC timestamps"
- OVERVIEW.md documents model lineage

**Month 2+**: Mature
- OVERVIEW.md has complete model inventory
- ADR has 5-10 key decisions documented
- New team members can onboard via docs

## Example: Legacy Rails Application

Another adoption scenario - a mature Rails app.

### Generated CLAUDE.md

```markdown
# OrderFlow (Rails)

> E-commerce order management system, ~5 years old.

## Quick Context

- **Type**: Existing Rails app (adoption mode)
- **Stack**: Rails 7, PostgreSQL, Redis, Sidekiq
- **Git Workflow**: PR Review (GitHub)
- **Tickets**: GitHub Issues (#XXX)

## Structure

```
app/
├── controllers/    # API and web controllers
├── models/         # ActiveRecord models
├── services/       # Business logic (newer code)
├── jobs/          # Sidekiq background jobs
└── views/         # ERB templates (legacy)
```

## Key Patterns

- **Older code**: Fat models, some controllers have logic
- **Newer code**: Service objects in app/services/
- **Testing**: RSpec, factory_bot, ~60% coverage

## Commands

```bash
# Run tests
bundle exec rspec

# Run specific test
bundle exec rspec spec/services/order_service_spec.rb

# Console
bundle exec rails c
```

## Working Agreements

1. New code uses service objects
2. Tests required for new features
3. Follow existing patterns unless ADR says otherwise
```

### Generated Agent Guide (data.md)

For DBT projects, instead of backend/frontend agents:

```markdown
# Data Modeling Agent

> Guidelines for DBT development in this project.

## Model Layers

### Staging (models/staging/)
- 1:1 with source tables
- Rename columns to standard conventions
- Cast data types
- No joins, minimal transformations

### Intermediate (models/intermediate/)
- Business logic building blocks
- Can join staging models
- Reusable across marts

### Marts (models/marts/)
- Final consumption models
- Optimized for BI tools
- May be wide and denormalized

## Testing Requirements

Every model needs:
- `unique` test on primary key
- `not_null` on required fields
- Relationship tests for foreign keys

## Before Creating MR

```bash
# Run full build on changes
dbt build --select state:modified+

# Check documentation
dbt docs generate
```

## Common Patterns

### Incremental Models
```sql
{{
  config(
    materialized='incremental',
    unique_key='id',
    on_schema_change='sync_all_columns'
  )
}}

SELECT ...
{% if is_incremental() %}
WHERE updated_at > (SELECT MAX(updated_at) FROM {{ this }})
{% endif %}
```

### Surrogate Keys
```sql
{{ dbt_utils.generate_surrogate_key(['field1', 'field2']) }} as sk_id
```
```

## Feature-Scoped Documentation

For large projects with multiple parallel features, project-level documentation doesn't scale. Use **feature-scoped documentation** to track work per feature.

### When to Use Feature Docs

- Multiple features in flight simultaneously
- Features span multiple sessions/weeks
- Different team members on different features
- Need to track feature-specific decisions and progress

### Feature Documentation Structure

```
project/
├── CLAUDE.md                    # Project context
├── docs_specflow/
│   ├── OVERVIEW.md              # Project architecture
│   ├── ADR.md                   # Project decisions
│   ├── ROADMAP.md               # All tasks with [feature: name] tags
│   ├── SESSION_LOG.md           # All sessions with [feature-name] prefix
│   └── feature_docs/            # Per-feature specs
│       ├── customer-dimension/
│       │   └── SPEC.md          # Feature specification (frozen north star)
│       └── order-metrics/
│           └── SPEC.md
```

### Creating a New Feature

Use the `/new-feature` command (see [templates/commands/new-feature.md](../templates/commands/new-feature.md)):

```
/new-feature customer-dimension
```

This will:
1. Ask clarifying questions about the feature
2. Optionally scan relevant code for context
3. Create `docs_specflow/feature_docs/<name>/SPEC.md`
4. Add feature tasks to central `docs_specflow/ROADMAP.md` with `[feature: name]` tags
5. Link to ticket/MR if provided

### Feature SPEC.md

The feature spec is your **north star** - what you're building and why:

```markdown
# Feature: Customer Dimension

## Ticket
- Jira: DATA-456
- MR: !123

## Overview
Add a customer dimension to the marts layer for customer-centric analytics.

## Requirements
- Source: Salesforce accounts + internal user data
- Grain: One row per customer (Salesforce Account ID)
- Key attributes: name, industry, region, ARR, health score

## Upstream Dependencies
- stg_salesforce__accounts
- stg_internal__users
- int_customers__enriched

## Downstream Consumers
- fct_orders (will join to dim_customer)
- Looker customer dashboard

## Success Criteria
- [ ] All customer attributes populated
- [ ] Joins correctly to fct_orders
- [ ] dbt tests pass (unique, not_null, relationships)
- [ ] Looker dashboard shows correct data

## Open Questions
- [ ] How to handle customers without Salesforce account?
- [ ] SCD Type 1 or Type 2 for historical tracking?

## Decisions Made
- 2024-01-15: Using SCD Type 1 for MVP, revisit Type 2 later
```

### Feature ROADMAP.md

Tracks progress for this specific feature:

```markdown
# Roadmap: Customer Dimension

**Feature**: customer-dimension
**Ticket**: DATA-456
**MR**: !123
**Branch**: feat/DATA-456-customer-dim

## Now
- [ ] Create dim_customer model with core attributes

## Next
1. Add schema.yml with tests
2. Join to fct_orders
3. Update Looker dashboard

## Later
- Add SCD Type 2 tracking
- Add customer segmentation fields

## Done
- [x] Create feature spec (2024-01-15)
- [x] Identify upstream dependencies (2024-01-15)

## Blockers
- None
```

### Feature SESSION_LOG.md

Session history for this feature only:

```markdown
# Session Log: Customer Dimension

## Session: 2024-01-16

**Task**: Create dim_customer model
**Branch**: feat/DATA-456-customer-dim

### Summary
- Created dim_customer.sql in marts/core/
- Added basic attributes from stg_salesforce__accounts
- Ran successfully against dev

### Files Changed
- models/marts/core/dim_customer.sql (new)

### Decisions
- Using account_id as primary key (not surrogate for now)

### Next
- Add schema.yml with tests
- Add remaining attributes from int_customers__enriched

---

## Session: 2024-01-15

**Task**: Feature setup

### Summary
- Created feature spec
- Identified upstream dependencies
- Created roadmap

### Files Changed
- docs_specflow/feature_docs/customer-dimension/SPEC.md (new)
- docs_specflow/ROADMAP.md (added [feature: customer-dimension] tasks)

---
```

### Feature-Aware Session Commands

When working on a feature, session commands reference the feature docs:

**plan-session.md** (feature mode):
```markdown
Working on feature: customer-dimension

Read feature context:
- docs_specflow/feature_docs/customer-dimension/SPEC.md (requirements)
- docs_specflow/ROADMAP.md (filter tasks tagged [feature: customer-dimension])
- docs_specflow/SESSION_LOG.md (recent sessions for this feature)

Plan the next task from the ROADMAP.
```

**end-session.md** (feature mode):
```markdown
Update documentation:
- docs_specflow/ROADMAP.md (mark task done)
- docs_specflow/SESSION_LOG.md (add entry with [customer-dimension] prefix)

If feature is complete:
- Update docs_specflow/ADR.md if decisions were made
```

### When Features Complete

When a feature is done:
1. Mark all feature tasks as done in `docs_specflow/ROADMAP.md`
2. Add final `docs_specflow/SESSION_LOG.md` entry
3. Update `docs_specflow/ADR.md` if significant decisions were made
4. Update `docs_specflow/OVERVIEW.md` if architecture changed

### Example: DBT Feature Workflow

```bash
# Start new feature
/new-feature customer-dimension
# Answer questions, create docs

# Plan first session
/plan-session --feature customer-dimension

# Work on feature
/start-session --feature customer-dimension
# ... implement ...
/end-session --feature customer-dimension

# Continue in later sessions
/plan-session --feature customer-dimension
# ... and so on until done
```

---

## Adoption Checklist

When adopting SpecFlow to an existing project:

- [ ] Run init prompt, declare "adoption" mode
- [ ] Allow or describe codebase scan
- [ ] Confirm tech stack and git workflow
- [ ] Review generated CLAUDE.md
- [ ] Start first session with a real task
- [ ] Build documentation incrementally
- [ ] Add ADR entries as decisions are made
- [ ] Expand OVERVIEW.md as understanding grows
- [ ] Use feature docs for larger, multi-session work

## Common Adoption Patterns

| Project Type | Key Docs | Special Considerations |
|--------------|----------|------------------------|
| DBT | OVERVIEW (model inventory), ADR (modeling decisions) | Feature docs per data mart |
| Rails/Django | OVERVIEW (app structure), ADR (tech debt decisions) | Feature docs per epic |
| React SPA | OVERVIEW (component hierarchy), ADR (state management) | Feature docs per page/flow |
| Microservices | OVERVIEW (service map), ADR (API contracts) | Feature docs per service change |
| Mobile | OVERVIEW (screens/flows), ADR (platform decisions) | Feature docs per screen |

---

*See [prompts/INIT.md](../prompts/INIT.md) for the initialization prompt - declare "adoption" mode when asked.*
